User => parser => matcher => User

parser and matcher use FSM constructors


fsm: constructors producing state-to-state machines effecting transitions; return fsm pointers

	add state-to-state transitions
		substring

		and
		or
		maybe
		kleene star
	
	add epsilon transitions

matcher: in: fsm, str; out: returns boolean (match?) or first match, or collection of matches

	two queues implemented as linked lists: one for states and one for strings
		enqueue (unless queue is full)
		resize (if enqueue fails)
		dequeue (return null pointer if empty)
	

parser: for constructing FSM from regex string
	also a finite-state machine
	booleans: SUBST, ESCAPED, CHARCLASS
		ESCAPED: [, ], (, ), *, ., ?, ^, $

	while there is a next character c
		switch c